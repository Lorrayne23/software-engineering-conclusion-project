The cc command
This command analyzes Python source files and compute Cyclomatic Complexity. The output can be filtered by specifying the -n and -x flags. By default, the complexity score is not displayed, the option -s (show complexity) toggles this behaviour. File or directories exclusion is supported through glob patterns. Every positional argument is interpreted as a path. The program then walks through its children and analyzes Python files. Every block will be ranked from A (best complexity score) to F (worst one). Ranks corresponds to complexity scores as follows:

CC score	Rank	Risk
1 - 5	A	low - simple block
6 - 10	B	low - well structured and stable block
11 - 20	C	moderate - slightly complex block
21 - 30	D	more than moderate - more complex block
31 - 40	E	high - complex block, alarming
41+	F	very high - error-prone, unstable block
Blocks are also classified into three types: functions, methods and classes. They’re listed by letter in the command output for convenience when scanning through a longer list of blocks:

Block type	Letter
Function	F
Method	M
Class	C

MI score	Rank	Maintainability
100 - 20	A	Very high
19 - 10	B	Medium
9 - 0	C	Extremely low

The raw command
This command analyzes the given Python modules in order to compute raw metrics. These include:

LOC: the total number of lines of code
LLOC: the number of logical lines of code
SLOC: the number of source lines of code - not necessarily corresponding to the LLOC [Wikipedia]
comments: the number of Python comment lines (i.e. only single-line comments #)
multi: the number of lines representing multi-line strings
blank: the number of blank lines (or whitespace-only ones)

hal
 h1: 11
    h2: 34
    N1: 24
    N2: 47
    vocabulary: 45
    length: 71
    calculated_length: 211.02748440752185
    volume: 389.9215698394069
    difficulty: 7.602941176470588
    effort: 2964.5507589260787
    time: 164.69726438478216
    bugs: 0.12997385661313562a

flake8

0,MotionPlanning,E501,"['line', 'too', 'long', '(94', '>', '79']"
1,MotionPlanning,F841,"['local', 'variable', ""'K'"", 'is', 'assigned', 'to', 'but', 'never']"

Multimetric
Repository,comment_ratio,cyclomatic_complexity,fanout_external,fanout_internal,halstead_bugprop,halstead_difficulty,halstead_effort,halstead_timerequired,halstead_volume
0,PythonRobotics,6.945725434551259,49,11,1,6.9443360153260185,117.16742081447963,2440949.8205545507,135608.32336414172,20833.008045978055

Smelly-Python
Repository,Smell Type,Information
0,SqueezeSeg,E0001,(syntax-error)
1,VoxFormer,C0114,(missing-module-docstring)
2,VoxFormer,E0401,(import-error)
3,VoxFormer,E0401,(import-error)


RQ1:Quais os code smells frequentemente encontrados em reposit ́orios de ADS?
Observar classificação em https://refactoring.guru/pt-br/refactoring/smells e classificar de acordo com as informações
obtidas em smelly-python e flake 8 , contabilizar as ocorrências e apontar as denominações mais frequentes de code smell.

RQ2:Existe uma relac̃ao entre m ́etricas de qualidade e code smells em repositoriosADS?
Utilizar dados de radon e multimetric
Contabilizar a quantidade de code smells de cada repositorio
Criar uma relação númerica com métricas de qualidade

RQ3:Reposit ́orios ADS que possuem releases apresentam valores de m ́etricas e
smells distintos em relac ̧  ̃ao a reposit ́orios ADS que n ̃ao possuem releases?

Comparar os repositórios que apresentam releases e aqueles que não apresentam
em relação a quantidade de code smells encontrados e as métricas de qualidade.




Bloaters
Bloaters are code, methods and classes that have increased to such gargantuan proportions that they are hard to work with. Usually these smells do not crop up right away, rather they accumulate over time as the program evolves (and especially when nobody makes an effort to eradicate them).

Long Method
Large Class
Primitive Obsession
Long Parameter List
Data Clumps

Object-Orientation Abusers
All these smells are incomplete or incorrect application of object-oriented programming principles.

Alternative Classes with Different Interfaces
Refused Bequest
Switch Statements
Temporary Field

Change Preventers
These smells mean that if you need to change something in one place in your code, you have to make many changes in other places too. Program development becomes much more complicated and expensive as a result.

Divergent Change
Parallel Inheritance Hierarchies
Shotgun Surgery

Dispensables
A dispensable is something pointless and unneeded whose absence would make the code cleaner, more efficient and easier to understand.

Comments
Duplicate Code
Data Class
Dead Code
Lazy Class
Speculative Generality

Couplers
All the smells in this group contribute to excessive coupling between classes or show what happens if coupling is replaced by excessive delegation.

Feature Envy
Inappropriate Intimacy
Incomplete Library Class
Message Chains